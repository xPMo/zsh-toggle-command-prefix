#!/usr/bin/env zsh
emulate -L zsh
setopt extendedglob

local -a reply
local REPLY{,2}
split-shell-arguments

local end_cmd=$'(\n##''|\||\|\||&&|;)'
local -i end_loc=2+"${${(@)reply[0,REPLY]}[(I)$~end_cmd]}"
local -i new_loc=end_loc
if [[ "$reply[end_loc]" = (if|elif|then|else|while|do|until|\{|\() ]]; then
	end_loc+=2
fi
if [[ "$reply[end_loc]" = command ]]; then
	end_loc+=2
fi
new_loc=end_loc

# $1: the text to insert
# $2: (pattern) the command to remove
# $3: (pattern) remove if found after the command
# $4: (pattern) remove with following arg if found after command
# e.g.:  .toggle-command-prefix 'nice ' 'nice' '--adjustment=*' '(--adjustment|-n)'
if ! [[ $1 ]]; then
	# parsed from _sudo function using ../gen_sudo_opts.zsh
	set -- 'sudo ' 'sudo' \
		'(-S|-A|--askpass|-h|--help|-K|--remove-timestamp|-k|--reset-timestamp|-l|--list|-n|--non-interactive|-S|--stdin|-V|--version|-v|--validate|-e|--edit|-s|--shell|-i|--login|-b|--background|-E|-H|--set-home|-P|--preserve-groups|opt_args|(-C?|--close-from=|-g?|--group=|-h?|--host=|-p?|--prompt=|-r?|--role=|-t?|--type=|-T?|--command-timeout=|-U?|--other-user=|-u?|--user=|--preserve-env=)*)' \
		'(-C|--close-from|-g|--group|-h|--host|-p|--prompt|-r|--role|-t|--type|-T|--command-timeout|-U|--other-user|-u|--user)*'
fi
insert=$1
cmdmatch=$2
shift 2
# (Q) removes one layer of quotes
if [[ ${(Q)reply[new_loc]} = $~cmdmatch ]]; then
	# found command, remove it
	while (($#reply > new_loc )); do
		# found (possibly quoted) argument
		case ${(Q)reply[new_loc+2]} in
		$~1)
			((new_loc+=2))
			continue ;;
		$~2)
			((new_loc+=4))
			continue ;;
		esac
		break
	done
	if ((REPLY > new_loc + 1)); then
		((CURSOR = CURSOR - ${#${(j::)reply[end_loc,new_loc+1]}}))
	else
		((CURSOR = ${#reply[0,new_loc-1]} + 1))
	fi
	CUTBUFFER=${(j::)reply[end_loc,new_loc+1]}
	BUFFER="${(j::)reply[0,end_loc-1]}${(j::)reply[new_loc+2,-1]}"
else
	((CURSOR += $#1))
	BUFFER=${(j::)reply[0,new_loc-1]}$insert${(j::)reply[new_loc,-1]}
fi
